# 《实现领域驱动设计》

----

# 第一章 DDD 入门

## DDD 是什么

DDD 是一种思想，无关系统大小，他是教我们怎样开发好的软件，DDD 并非标新立异之物，而是软件发展的自然结果

其实我们在开发中都不知不觉的使用了一些 DDD 的知识，这些知识是我们在工作中自己摸索出来的，但是大师们在得出知识的基础上还能进行抽象和总结，并以流畅的方式表达出来，让大家都能受益

我们的目标是构建可测试、可伸缩、组织良好的软件

DDD 并不是关于技术的，而是关于讨论、聆听、理解、发现和业务价值的，而这些都是为了将知识集中起来

## 为什么需要 DDD

* 业务专家和开发者一起工作，这样开发出来的软件更准确的传达业务规则，就像代码是业务人员写的一样
* 帮助业务人员更精通业务
* 知识共享，将知识固化到软件中，代码就是设计，设计就是代码
* 统一语言，避免开发人员和业务人员之间的翻译
* DDD 同时提供了战略设计和战术设计两种方式，战略设计让我们确定哪些是重要的，战术设计帮助我们构建 DDD 的各个组件

### 常见的两个症状

贫血对象和失忆症

## 如何 DDD

两大支柱

* 通用语言
* 限界上下文

### 通用语言

`通用语言`是整个团队共享的一套语言，大家对概念的理解是一致的，对于不一致的地方，由于讨论和沟通，最终也要达成一致

大家都用一套语言沟通，就算有人离开也不影响团队的合作

举一个使用`通用语言`开发的例子，护士给病人注射流感疫苗

**第一种** 

```java
patient.setShotType(ShotTypes.TYPE_FLU);
patient.setDose(dose);
patient.setNurse(nurse);
```

**第二种**

```java
patient.giveFluShot();
```

**第三种**

```java
Vaccine vaccine = vaccines.standardAdultFluDose();
nurse.administerFluVaccine(patient, vaccine);
```

显然第三种更清晰，表达意图更准确

#### 如何掌握通用语言

建立术语表，各种术语都列出来，给出明确的定义，大家都按这个定义来沟通

### 限界上下文

一套`通用语言`是使用在一个`限界上下文`中的，不同`限界上下文`中同一个术语意义可能不同，这时需要进行`限界上下文`的映射，`限界上下文`的内容在下一章

## DDD 的业务价值

1. 获得了一个给常有用的领域模型（把精力花在有价值的东西上）
2. 对业务有了更准确的定义和理解
3. 领域专家可以为软件设计做出贡献
4. 更好的用户体验（对领域理解越深，设计出的软件往往更易于使用）
5. 清晰的边界模型，利于将技术资源集中在交付价值上
6. 更好的企业架构，通过对`限界上下文`的划分，更好的理解了企业的业务内容
7. 敏捷、迭代式和持续建模
8. 使用战术和战略新工具

## 实施 DDD 所面临的挑战

当我们对一个领域进行建模时，我们需要仔细考虑对象做什么事情，这是关于对象行为设计的。我们希望对象行为的命名能够传达准确的业务含义，也即反应`通用语言`。要达到这样的目的，显然不是定义属性和 getter、setter 这么简单的事情

DDD 可以和测试驱动开发配合的很好，开发之前，先写测试代码，此时测试代码模拟客户代码对模型的使用方式，测试代码驱动着模型的设计，在模型编写之后，添加更多的测试，此时关注的是领域对象的表达力，测试代码便是`通用语言`在程序中的表达

# 第二章 领域、子域和限界上下文

广义上讲，`领域`即是一个组织所做的事情以及其中包含的一切

一个`领域`被分成若干`子域`，`子域`又有三种类型

* 核心子域
* 支撑子域
* 通用子域

我们的关注点要从`核心域`出发

理想情况是一个`限界上下文`与一个子域对应，一个`限界上下文`中的一个概念是不会有多种意义的

实际情况中，很多垃圾软件的存在是一个事实，所以，以上的理想情况通常达不到，你需要和已有的软件系统进行集成

`限界上下文`主要是一个语义上的边界，我们应该通过这一点来衡量对一个`限界上下文`的使用正确与否

当需要集成时，我们必须在不同的`限界上下文`之间进行概念映射

我们需要识别出那些区别微小的概念，看看是否在不同的`限界上下文`中进行了分离

`限界上下文`也不是一成不变的，在每一个迭代中，我们对要对之前的假设提出挑战，看看需要修改哪些概念，加入哪些概念，删除哪些概念

`限界上下文`的建模应该是从`通用语言`的角度进行思考，而不是为了满足架构组件或者开发资源进行考虑

# 第三章 上下文映射图

`上下文映射图`主要帮助我们从解决方案空间的角度看问题

`上下文映射图`反应的是项目当前的状态，随着项目的研究，`上下文映射图`也会随之更改

两个`限界上下文`有哪些关系？

* 合作关系（一起成功，一起失败）
* 共享内核（内核尽量小）
* 客户方-供应方
* 遵奉者
* 防腐层
* 开放主机服务
* 发布语言
* 另谋他路
* 大泥球

通常来说，一个外部的概念需要翻译才能够进入当前的`限界上下文`

我也根据图中的实例画了自己系统中一个简单的`上下文映射图`

![](../images/qone-jigsaw-context-map.png)

> 此图采用 Omni Graffle 所画，也算与本季度的第二个目标进行了关联

# 第四章 架构

* 风险驱动架构
* 用例驱动架构

不同的架构风格

## 分层

严格分层架构和松散分层架构

本章的介绍几乎提到了后文讲到的所有概念，在这里可以有一个总体的了解，第一遍可能不会全懂，需要看完后面之后回来再读一下

## 六边形架构（端口与适配器）

将分层架构摊平了，核心是`领域模型`，外层是`应用程序`，最外层是端口和适配器，所有输入输出都通过端口和适配器进行处理

`资源库`可以看作是持久化适配器

六边形架构的一大好处在于，我们可以轻易的开发用于测试的适配器，整个应用程序和领域模型可以在没有客户和存储机制的条件下进行开发

## 面向服务的架构

1. 业务价值高于技术策略
2. 战略目标高于项目利益

技术组件对于划分模型来说并没有那么重要，用例和功能才是驱动架构的根本

## REST

REST 是一种 Web 应用架构风格，是使用 Web 协议的推荐方式

RESTful HTTP 服务的关键方面

* 资源是关键
* 无状态
* 通过超媒体，客户端可以沿着某种路径发现应用程序可能存在的状态变化

REST 架构具有很好的松耦合性和可伸缩性

## 命令和查询职责分离——CQRS

该架构中，改状态的操作是命令，命令操作没有返回值，查询操作不可以修改状态

一般用在用户显示界面特别复杂的时候

## 事件驱动架构

管道和过滤器

### 长时处理过程

设计长时处理过程的三种方法

1. 一系列组合任务，有一个调度组件进行跟踪
2. 设计成一组聚合，这些聚合在一系列活动中相互合作，一个或多个聚合实例充当执行组件并维护整个处理过程的状态
3. 组件无状态，每个处理器都对事件增加状态

第一种方法，需要一个跟踪器对象

长时处理过程要考虑消息重复投递、状态跟踪、超时检测、处理失败的补偿等

### 事件源

**这里的定义：**对于某个`聚合`上的每个命令操作，都会发布一个`领域事件`，这个`领域事件`描述了操作的执行结果。每个`领域事件`都被保存在`事件存储`中，这些`领域事件`可以实现对`聚合`所做的操作进行重放

为了避免事件过多，可以采用快照

## 数据网织和基于网格的分布式计算

Data Fabric 书中说的不是很明白，得再看看别的资料

# 第五章 实体

`实体`与`值对象`的区别

* 可变性
* 唯一身份标识

## 唯一标识

在设计`实体`时，我们应该优先考虑本质特征，特别是`实体`的唯一标识和对`实体`的查找，而不是一开始就关注`实体`的属性和行为

生成策略

1. 用户提供
2. 应用程序生成
3. 数据库生成
4. 外部`限界上下文`获得

有时，标识的生成时间和赋值时间对`实体`来说是重要的，及早标识生成和赋值发生在持久化`实体`之前，延迟生成和赋值发生在持久化`实体`的时候

标识稳定性，要保证标识在创建后不被修改，可以采用 setter 方法自封装性来实现，例如

```java
protected void setName(String name) {
    if (this.name != null) {
        throw new IllegalStateException("The name may not be changed.");
    }
    if (name == null) {
        throw new IllegalArgumentException("The name may not be set to null.");
    }
    this.name = name;
}
```

## 发现实体及其本质特征

主要是唯一标识和用于对实体进行查找的属性

## 挖掘实体的关键行为

`意图展现接口(Intention Revealing Interface)`

## 领域对象扮演多重角色

一个领域对象可以实现多个接口

角色接口最实用之处可能也是最简单之处。通过接口，我们可以将实现细节隐藏起来，从而不至于将实现细节泄漏到客户端中。我们所设计的接口应该刚好满足客户端的需求，不多也不少。

## 实体创建

不变性条件


通过自封装性维护实体的不变性条件，在只通过 setter 给属性复制，只通过 getter 获取属性值

## 验证

三个验证级别

* 属性验证
* 对象验证
* 对象组合验证

### 属性验证

强烈推荐使用自封装性来实现

### 对象验证

将验证对象的职责放在单独的对象中对合适的，单独的验证对象也将验证逻辑的变化与实体对象的变化分离开来，并且有助于对复杂验证过程的测试

验证过程应该收集到所有的验证结果，而不是在一开始遇到非法状态时就抛出异常

### 验证对象组合

使用`领域服务`进行对象组合验证是比较合适的，还可以在租户上创建一个状态标识来表明是否可以进行验证，当验证条件成熟时，模型通过发送`领域事件`的方式通知客户方

# 第六章 值对象

## 值对象的特征

### 1. 度量或描述了领域中的一件东西

### 2. 它可以作为不变量

* 一般通过构造函数来保证，构造成功之后状态便不可修改

### 3. 它将不同的相关的属性组合成一个概念整体

```java
// 错误的建模
public class ThingOfWorth {
    private String name;
    private BigDecimal amount;
    private String currency;
}

// 使用值对象的建模
public class ThingOfWorth {
    private ThingName name;
    private MonetaryValue worth; // 成为了一个概念整体
}

public class MonetaryValue {
    private BigDecimal amount;
    private String currency;
    
    public MonetaryValue(BigDecimal anAmount, String aCurrency) {
        this.setAmount(anAmount);
        this.setCurrency(aCurrency);
    }
}
```

### 4. 当度量和描述改变时，可以用另一个值对象予以替换

### 5. 它可以和其他值对象进行相等性比较

### 6. 他不会对协作对象造成副作用

值对象的行为不改变该值对象的状态

我们应该尽量使值对象只依赖于他自己的属性，并且只理解自身的状态，虽然在有些情况下并不可行，但这是我们的目标

要增加一个值对象的健壮性，我们传给值对象方法的参数应该依然是值对象，这样我们可以获得更高层次的无副作用行为

## 最小化集成

上游上下文只通过值对象向下游上下文传递下游上下文需要的内容

## 用值对象标识标准类型

Java 中可以通过 enum 来实现

## 测试值对象

测试驱动可以帮助我们从客户的角度设计领域模型

## 实现

要保持对象的不变性，只有主构造函数可以使用自委派性来设置属性值，除此之外，其他方法都不能使用 setter 方法

## 持久化值对象

这里我们讨论的是包含多个`值对象`的`聚合`的持久化

我们要从领域模型的角度设计数据模型，而不是根据数据模型来设计领域模型

### ORM 与单个值对象

采用 Hibernate 的 component 映射

### 多个值对象序列化到单个列中

例如 List 或者 Set，只能转成文本存储，有一些明显的缺点

* 列宽
* 无法通过值对象的属性茶性
* 需要自定义 Hibernate 类型进行转换

### 使用数据库实体保存多个值对象

采用`超层类型`模式

```java
public abstract class IdentifiedDomainObject {
    private long id = -1;
    
    public IdentifiedDomainObject() {
        super();
    }
    
    protected long id() {
        return this.id;
    }
    
    protected void  setId(long id) {
        this.id = id;
    }
}

public abstract class IdentifiedValueObject extends IdentifiedDomainObject {
    
    public IdentifiedValueObject() {
        super();
    }
}
```

这样可以防止持久化信息泄露到领域模型中

### 使用联合表保存多个值对象

限制性很大，几乎不用

### ORM 与枚举状态对象

这个简单，使用框架提供的方案映射就好

# 领域服务

领域中的服务表示一个无状态的操作，它用于实现特定于某个领域的任务

`应用服务`与`领域服务`的区别，`应用服务`不处理业务逻辑，`领域服务`处理业务逻辑，`应用服务`是`领域服务`的客户方

`领域服务`一般有有如下作用：

* 执行一个显著的业务操作过程
* 对领域对象进行转换
* 以多个领域对象作为输入进行计算，产生一个值对象

> 要避免滥用`领域服务`，而产生贫血对象

`领域服务`如果有多个实现类，就定义一个接口，如果只有一个实现类就无需定义接口

总有人这么干，定义一个 XService，再定义一个实现类 XServerImpl，这个的实现没有任何意义，没有表达出任何与接口的区别，还不如将逻辑写在 XService 中

`领域服务`中不应该负责安全和事务，这些应该是`应用服务`做的事情

通过测试驱动开发来从客户的角度设计`领域服务`

# 领域事件

`领域事件`是领域模型的组成部分，表示领域中所发生的事情

## 为何/何时使用领域事件

* 解耦系统，实现更好的伸缩性
* 事件包含信息，可以减少复杂查询，下游系统使用事件中的信息即可知道要做什么
* 取代批处理过程，提高实时性

## 建模领域事件

根据`限界上下文`中的`通用语言`来命名事件，`领域事件`表示发生过的事情，应该用过去时态

例如 `BacklogItemCommitted`、`UserRegistered` 等

最容易识别的就是当一个`聚合`依赖于另外一个`聚合`的时候，此时我们需要保证他们之间的最终一致性

事件消息可能重复投递，需要给`领域事件`一个唯一标识

## 从领域模型中发布领域事件

避免将领域模型暴露给任何类型的消息中间件，这些消息中间件只存在于基础设施层中

通常由`应用服务`来完成对事件订阅方的注册，有时也由`领域服务`完成

事件订阅方不应该在另一个`聚合`上执行命令方法，因为这样会破坏“在单个事务中只修改单个聚合实例”的原则

## 向远程限界上下文发布领域事件

我们要考虑消息设施的一致性和系统可接受的延时

## 转发存储事件的架构风格

### 以 REST 资源的方式发布事件通知

```
HTTP/1.1 200 OK
Content-Type: application/vnd.sassovation.idovation+json
...
Link: <http://iam/notifications/61,80>; rel=next
Link: <http://iam/notifications/41,60>; rel=self
Link: <http://iam/notifications/21,40>; rel=previos
...
```

### 通过消息中间件发布事件通知

要考虑消息重复投递，接收方需要实现`幂等接收器`模式

# 第九章 模块

## 设计模块的原则

* `模块`应该和领域概念保持一致
* 根据`通用语言`来命名`模块`
* 不要机械式的根据通用的组件类型和模式来创建`模块`
* 设计松耦合的`模块`
* 当同层`模块`间出现耦合时，不要引入循环依赖
* 在父子`模块`之间可以放松依赖原则
* 不要将`模块`设计成一个静态的概念，应该和领域对象一道进行建模

## 命名

顶级域.限界上下文.domain.model
顶级域.限界上下文.domain.service
顶级域.限界上下文.domain.repository
顶级域.限界上下文.application.xxx
顶级域.限界上下文.resource.xxx

先考虑`模块`，再考虑`限界上下文`

# 第十章 聚合

这是最难的一章

一方面，我们可能为了对象组合上的方便，将`聚合`设计的很大；另一方面，我们设计的`聚合`又可能因为过于贫瘠丧失了保护真正不变条件的目的。我们应该同时避免这两个极端，将注意力集中在业务规则上

`聚合`讨论的问题：**对象组合、信息隐藏、一致性边界、事务**

## 原则：在一致性边界只能建模真正的不变条件

在提交事务时，边界之内的所有内容都必须保持一致。对于一个设计良好的`聚合`来说，无论由于何种业务需要而发生改变，在单个事务中，`聚合`中的所有不变条件都是一致的。而对于一个设计良好的`限界上下文`来说，无论在哪种情况下，它都能保证在一个事务内只修改一个`聚合`实例

在一个事务中只修改一个`聚合`实例，是一条重要的经验原则，也是我们为什么要使用`聚合`的原因

## 原则：设计小聚合

使用根`实体`来表示`聚合`，其中只包含最小数量的属性或值类型属性（那些必须与其他属性保持一致的属性）

小`聚合`不仅有性能和可伸缩性上的好处，还能减少事务提交的冲突

对于一次要操作多个`聚合`的用例，我们最好用最终一致性，而不是在一个事务中修改多个`聚合`

## 原则：通过唯一标识引用其他聚合

可以一定程度避免同时修改两个`聚合`

避免在`聚合`命令方法中使用`资源库`

## 原则：在边界之外使用最终一致性

对于一个用例，问问是否应该由执行该用例的用户保证数据的一致性，如果是，请使用事务一致性，如果需要其他用户或者系统来保证数据一致性，请使用最终一致性

> 花些时间进行团队讨论，看看应该设计什么规格的`聚合`是有价值的

## 实现

注意领域标识和实体委派标识的区别

优先使用`值对象`

迪米特法则（最小知识原则）和“告诉而非询问”原则，我只关心你能干什么，不关心你怎么干的

不要在`聚合`中注入`资源库`

这章比较难懂，多是经验之谈，没有切身体会不好理解，值得以后回头再看看

# 第十一章 工厂

`工厂`并不承担除创建对象之外的职责

优势

* `工厂`比构造函数能更好的表达`通用语言`
* 可以减轻客户端的负担，比如可以少传几个参数
* 维护对象的不变性，确保`工厂`产生的对象处于正确的状态


# 其他资料

* [《实现领域驱动设计》阅读日志](../reading_record/《实现领域驱动设计》阅读日志.md)
